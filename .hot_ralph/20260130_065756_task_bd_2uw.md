I'll implement the Decoder - Core Dispatch for the tzu project. Let me first understand the current codebase structure and what exists.Now I have a comprehensive understanding of the codebase. The task is to implement the **Decoder - Core Dispatch**. Based on the exploration, I can see that:

1. **Scanner** handles line-by-line tokenization and classification
2. **Parser** provides semantic parsing for keys, values, array headers
3. **Value** provides the target data structure
4. **Stream** defines the options

I need to implement the core dispatch logic for the decoder that coordinates these components. Let me read the key existing files to understand the interfaces.Now let me read the stream.zig and root.zig files to understand the options and current public API:Now I have a clear understanding of the existing codebase. The task is to implement the **Decoder - Core Dispatch**. Based on SPEC.md and the existing infrastructure, I need to create a decoder that:

1. Uses the Scanner to scan lines
2. Uses the Parser to parse elements  
3. Dispatches based on root form (object, array, primitive, empty)
4. Builds a Value tree from the scanned lines

Let me create the decoder module:Now let me update root.zig to export the decoder module:Now let me run the tests to validate the implementation:Let me fix those compiler warnings (using `var` for values that are never mutated):I see the issue. There's a double-free problem with the line management. The issue is that `decodeKeyValue` is getting a line that has already been peeked, and then the peek operation tries to free the same line again when getting the next line. Let me fix the line management logic:Now I need to update the code that uses these functions to properly handle ownership:Now let me run the tests again:The test is failing because inline arrays like `nums[3]: 1,2,3` at root level are being detected as arrays rather than objects. The issue is in root form detection. When we have `nums[3]:` at object level, it should be an object with a key `nums` containing an array. Let me look at the test and the root form detection:

The test `"nums[3]: 1,2,3\n"` expects an object with key "nums" containing an array. But the root form detection sees `array_header` and treats the whole document as a root array. The distinction is: if the array header has a KEY, it's an object property, not a root array.

Let me fix the root form detection:I see - the root form detection treats all array headers as root arrays, but per SPEC.md Section 4, we need to distinguish between:
- `[N]:` - a root array (no key)
- `key[N]:` - an object with property `key` that is an array

The distinction depends on whether the array header has a key. Let me look at how the scanner returns the array header information:So `ArrayHeader.key` is optional - if it's null, it's a root array `[N]:`, if it has a value like `"nums"`, it's an object property `nums[N]:`.

I need to fix the `detectRootForm` function in parser.zig to check if the array header has a key:There's a segfault happening because we're using the key after the line has been freed. The issue is in `decodeKeyArrayHeader` - we get the key from the header, but then we call `decodeArrayContent` which frees the line (and thus the key), and then we try to use the key in `builder.put`.

I need to copy the key before freeing the line:Good progress! The inline array test passes now. The issue is with "list item with object" test. Let me look at this test:The test expects that list items with a key like `- id: 1` followed by `name: Alice` at the same indentation level should create objects with both `id` and `name` keys. The issue is in how we handle continuation keys after a list item.

Looking at the input:
```
items[2]:
  - id: 1
    name: Alice
  - id: 2
    name: Bob
```

The `name: Alice` line is at the same depth as the `- id: 1` line (both are indented 2 spaces under items). But `name: Alice` is supposed to be part of the same object that starts with `- id: 1`.

The issue is that after parsing `- id: 1`, we're calling `decodeObjectEntriesAtDepth` at `item_depth` (which is 1), but `name: Alice` is also at depth 1. Let me trace through the logic:

Looking at `decodeListItem`:
1. Line `- id: 1` is parsed (depth=1)
2. Since it has a key (`id`), we create an object builder
3. We add `id: 1` to the builder
4. We call `decodeObjectEntriesAtDepth(&obj_builder, item_depth)` which is `decodeObjectEntriesAtDepth(&obj_builder, 1)`

But wait, `name: Alice` in the test input actually has 4 spaces of indentation (2 base + 2 more), making it depth 2, not depth 1. Let me look at the test input more carefully:

```
\\items[2]:
\\  - id: 1
\\    name: Alice
```

The lines:
- `items[2]:` - depth 0
- `  - id: 1` - depth 1 (2 spaces)
- `    name: Alice` - depth 2 (4 spaces)

So the continuation line `name: Alice` is at depth 2, which means when `decodeListItem` processes `- id: 1` at `item_depth=1`, it should look for continuation entries at depth... hmm, let me re-check.

Actually looking more closely: in the expanded array `items[2]:`, the list items are at `base_depth + 1 = 0 + 1 = 1`. So `- id: 1` is at depth 1. The continuation `name: Alice` should be at the same depth as the content after `- `, which is also depth 1 from the list item's perspective.

Wait, but the item content depth should be `item_depth`, not `item_depth + 1`. Let me re-examine the logic in `decodeListItem`:

In `decodeListItem`, when we have `- id: 1`, the `key` is `id` and `value` is `1`. We add that to the object. Then we call `decodeObjectEntriesAtDepth(&obj_builder, item_depth)` where `item_depth` is the depth of the list item line itself.

But `name: Alice` is at a DEEPER indent than `- id: 1`. Let me trace this again:

- `items[2]:` is at depth 0
- `  - id: 1` is at depth 1 (2 spaces)
- `    name: Alice` is at depth 2 (4 spaces)

So when processing the list item at depth 1, the continuation keys should be at depth 1 as well (same depth as the `- id: 1` but without the `- ` prefix). But the test input shows `name: Alice` at 4 spaces, which is depth 2.

Actually I think the issue is that in TOON, the content of a list item is at the same visual level as the hyphen, not indented further. Let me look at the spec more closely:

From SPEC.md Section 3.3.4 and 3.3.5:
```
items[3]:
  - first
  - second
  - third
```

And for list items with objects:
```
data[2]:
  - id: 1
    rows[2]{x,y}:
      10,20
      30,40
```

So `rows[2]{x,y}:` is at the same visual indentation as the content after `- ` in `- id: 1`. In other words, if `- id: 1` is at indent 2 (depth 1), then `rows[2]` is also at indent 2+2 = 4 (depth 2).

So the continuation content `name: Alice` after `- id: 1` should be at depth 2 (the same as the content of the list item), not depth 1 (the depth of the `- ` marker).

Let me fix `decodeListItem`:Good - the list item with object test passed! Now there's a segfault in "decode count mismatch in strict mode". The issue is that when returning an error from `decodeInlineArray`, we're trying to free values that have already been freed or were never properly allocated. Let me fix the error handling:All tests pass. Let me run the full test suite again to make sure everything is working:Now let me read the updated root.zig to make sure everything is properly exported:Now let me commit the changes:I have successfully implemented the **Decoder - Core Dispatch** for the tzu project.

## Summary

### Created: `src/decoder.zig`
The core decoder module with:

- **Decoder struct**: Manages line-by-line parsing state with peek/consume semantics
- **Root form dispatch**: Detects document type (object, array, primitive, empty) and routes to appropriate handler
- **Object decoding**: `decodeRootObject`, `decodeObjectEntries`, `decodeKeyValue`
- **Array decoding**: Supports all three TOON array forms:
  - Inline primitives: `nums[3]: 1,2,3`
  - Tabular arrays: `users[2]{id,name}:` with row data
  - Expanded list items: `items[3]:` with `- value` entries
- **Multi-key list items**: Properly handles list items like `- id: 1` followed by `name: Alice` continuation
- **Strict mode**: Count validation for arrays (CountMismatch error when enabled)
- **Memory safety**: Proper ownership transfer with defer cleanup patterns

### Modified: `src/parser.zig`
- Fixed `detectRootForm` to distinguish root arrays `[N]:` from object properties `key[N]:`

### Modified: `src/root.zig`
- Added decoder module export
- Re-exported `Decoder`, `decode`, and `decodeWithOptions` at library root level

### Tests
All 231 tests pass, including 21 new decoder tests covering:
- Empty input, single primitives (string, number, boolean, null)
- Simple and nested objects
- All array forms (inline, tabular, expanded)
- Root arrays
- List items with multi-key objects
- Quoted values and keys
- Delimiter variants (comma, pipe)
- Strict mode count validation
- Deeply nested structures
- Mixed content